${if len(unique_contexts_instances) > 0:}$${for instance in unique_contexts_instances:}$#include <Contexts/${"", to_class_name(instance)}$Context.h>

${:end-for}$${:end-if}$

${for data in executors_data:}$
${name = to_class_name(data.get("name"))}$
${"#include <executors/{}Executor.h>".format(name)}$

${:end-for}$
#include <dod/SharedContext.h>
#include <engine/Timer.h>
#include <engine/Bitmask.h>

namespace
{
${for instance in contexts_data:}$
${class_name = to_class_name(instance.context_name)}$
    ${"Game::Context::{}::Data {}Context;".format(class_name, instance.instance_name)}$
${:end-for}$
}

namespace
{
${for data in executors_data:}$
${class_name = "Game::ExecutionBlock::" + to_class_name(data.get("name"))}$
    ${"{} {};".format(class_name, data.get("name"))}$
${:end-for}$
}

struct OptionalExecutorsMask
{
    auto getIsEnabled(int32_t executorId) 
    {
        const auto batchId{ executorId / 64 };
        const auto localIndex{ executorId % 64 };
        return this->mask[batchId] & (1 << localIndex) != 0;
    }
    uint64_t mask[${"", num_of_optiona_executors}$];
};

struct FlowContext
{
    Engine::Bitmask::Bitmask<${num_of_parts_in_deps_mask}$> contextsReadyMask{ ${initial_context_mask}$ };
    Engine::Bitmask::Bitmask<1> completedExecutors{ };
${for desc in executors_per_contexts:}$
    int16_t ${"", desc.context_instance_name}$ExecutorsLeft{ ${"", len(desc.data)}$ };
${:end-for}$
};

namespace
{
    OptionalExecutorsMask enabledExecutors{};
}

namespace
{
${for context_data in executors_per_contexts:}$
    void merge${"", to_class_name(context_data.context_instance_name)}$()
    {
${for data in context_data.data_non_opt:}$
        ${"", data.executor_name}$.modify${"", to_class_name(data.context_target_name)}$(${"", context_data.context_instance_name}$Context);
${:end-for}$
${for data in context_data.data_opt:}$
        if (enabledExecutors.getIsEnabled(${"", data.optional_executor_id}$))
            ${"", data.executor_name}$.modify${"", to_class_name(data.context_target_name)}$(${"", context_data.context_instance_name}$Context);
${:end-for}$
    }

${:end-for}$
}

namespace
{
    bool tryRunNextExecutor(FlowContext& flowContext)
    {
${executor_el_id = 0}$
${for data in executors_deps_contexts:}$
        if (Engine::Bitmask::includes(flowContext.contextsReadyMask, { ${"", data.depenency_contexts_mask}$ }) && !Engine::Bitmask::get(flowContext.completedExecutors, ${executor_el_id}$))
        {
            tryRun${"", to_class_name(data.executor_name)}$();
${for context_name in data.contexts_list:}$
            --flowContext.${context_name}$ExecutorsLeft;
${:end-for}$
            Engine::Bitmask::set(flowContext.completedExecutors, ${executor_el_id}$);
            return true;
        }

${executor_el_id = executor_el_id + 1}$
${:end-for}$
        return false;
    }

    bool tryMergeNextContext(FlowContext& flowContext)
    {
${context_id = 0}$
${for desc in executors_per_contexts:}$
        if (flowContext.${"", desc.context_instance_name}$ExecutorsLeft == 0)
        {
            merge${"", to_class_name(desc.context_instance_name)}$();
            --flowContext.${"", desc.context_instance_name}$ExecutorsLeft;
            Engine::Bitmask::set(flowContext.contextsReadyMask, ${context_id}$);
            return true;
        }

${context_id = context_id + 1}$
${:end-for}$
        return false;
    }
}

int main()
{
${for instance in contexts_data:}$
    ${"", instance.instance_name}$Context.load();
${:end-for}$

${for data in executors_data:}$
${name = data.get("name")}$
    ${name}$.loadContext();
    ${name}$.initiate();
${:end-for}$

    Timer timer;
    float deltaTime{};
    while(true)
    {
        if (deltaTime >= 1.f / 60.f)
        {

            FlowContext flowContext{};

            while(true)
            {
                bool bChangeOccured{ false };
                bChangeOccured = tryRunNextExecutor(flowContext);
                bChangeOccured |= tryMergeNextContext(flowContext);

                if (!bChangeOccured)
                    break;
            }

            for (int32_t cmdId{}; cmdId < Dod::DataUtils::getNumFilledElements(sApplicationContext.commands); ++cmdId)
            {
                if (Dod::DataUtils::get(sApplicationContext.commands, 0) == 1)
                {
                    return 0;
                }
            }
            deltaTime = {};
        }

        timer.tick();
        deltaTime += timer.getDeltaTime();
    }
}
